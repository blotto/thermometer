{"name":"Thermometer","tagline":"Thermometer measures heat on your ActiveRecord Models and Associations","body":"Thermometer\r\n=======\r\n\r\n[<img src=\"https://secure.travis-ci.org/blotto/thermometer.png\" />](http://travis-ci.org/blotto/thermometer)\r\n[![Code Climate](https://codeclimate.com/github/blotto/thermometer.png)](https://codeclimate.com/github/blotto/thermometer)\r\n[![Dependency Status](https://gemnasium.com/blotto/thermometer.png)](https://gemnasium.com/blotto/thermometer)\r\n[![Coverage Status](https://coveralls.io/repos/blotto/thermometer/badge.png)](https://coveralls.io/r/blotto/thermometer)\r\n[![Gem Version](https://badge.fury.io/rb/thermometer.png)](http://badge.fury.io/rb/thermometer)\r\n\r\nThermometer measures heat on your ActiveRecord Models. This initial release is for Rails 4, not yet tested for Rails 3.\r\n\r\n### Mixins\r\nThis plugin introduces two mixins to your recipe book:\r\n\r\n1. **acts\\_as\\_thermometer** : Extends Instance with temperature methods\r\n2. **measure\\_temperature\\_for** : Allows customization on an association\r\n\r\n\r\n### Motivation\r\n\r\nThis plugin was started as a way for Bots to quickly assess the state of a User across many dimensions of Game play to\r\ndetermine automated actions for retention. For example, if a User went *cold* with regards to reading messages,\r\na reminder could be sent. Rather than dealing with dates and duration, coding uses a simplified syntax,\r\nfor example :\r\n\r\n    user = User.first\r\n    user.*call_to_some_action* if user.unread_messages.has_temperature?(:cold)  # false|true\r\n    user.*call_to_some_action* if user.unread_messages.is_colder_than?(:warm)   # false|true\r\n\r\n\r\nInstallation\r\n------------\r\n\r\nIn your gemfile\r\n\r\n```ruby\r\ngem \"thermometer\"\r\n#or to pick up a dev branch\r\ngem \"temperature\"  , github: 'blotto/temperature', :branch => \"first_release\"\r\n```\r\n\r\nThen at the command line\r\n\r\n\tbundle update --source temperature\r\n\trails generate temperature:install\r\n\r\nConfiguration\r\n-------------\r\n\r\nAfter install a YAML file is placed in the config directory, *config/thermometer.yml*. For a detailed description of the\r\navailable options, read the comments within the YAML file.\r\n\r\n### ActiveRecord Dependency\r\n\r\nModels must have the managed columns *created_at* and *updated_at* in order to evaluate the temperature.\r\n\r\nUsage\r\n-----\r\n\r\nMeasure the temperature on the Class , and on an Instance\r\n\r\n```ruby\r\nclass User < ActiveRecord::Base\r\n\r\n  acts_as_thermometer\r\n\r\nend\r\n```\r\n\r\n```ruby\r\nUser.has_temperature        # lukewarm\r\nUser.is_colder_than? :warm  # false\r\nUser.is_warmer_than? :cold  # true\r\n\r\nUser.first.has_temperature        # lukewarm\r\nUser.first.is_colder_than? :warm  # false\r\nUser.first.is_warmer_than? :cold  # true\r\n```\r\n\r\nMeasure the temperature on any association. NOTE: declare `measures_temperature_for` after your associations!\r\n\r\n```ruby\r\nclass User < ActiveRecord::Base\r\n\r\n  acts_as_thermometer\r\n\r\n  has_many :messages\r\n\r\n  has_many :oldest_messages, -> {where('created_at < ?', 4.months.ago)} , class_name: \"Message\"\r\n  has_many :recent_messages, -> {where('created_at > ? AND created_at < ?', 4.months.ago , 1.month.ago)} , class_name: \"Message\"\r\n  has_many :newest_messages, -> {where('created_at > ?', 1.month.ago)} , class_name: \"Message\"\r\n\r\n  measures_temperature_for :messages, :oldest_messages , :recent_messages , :newest_messages\r\n\r\n end\r\n```\r\n\r\n```ruby\r\nUser.first.messages.has_temperature               # temperate\r\nUser.first.oldest_messages.has_temperature        # frigid\r\nUser.first.recent_messages.is_colder_than? :warm  # false\r\nUser.first.newest_messages.is_warmer_than? :cold  # true\r\n```\r\n\r\nMethod Chaining\r\n-----\r\n\r\nYou can check the temperature on scopes...\r\n\r\n```ruby\r\nclass User < ActiveRecord::Base\r\n\r\n  acts_as_thermometer\r\n\r\n  class << self\r\n      def name_like(substring)\r\n        where(\"name LIKE '%#{substring}%'\")\r\n      end\r\n   end\r\n\r\n   def last_five_messages\r\n     messages.limit(5)\r\n   end\r\n\r\n end\r\n```\r\n\r\n```ruby\r\nUser.name_like(\"Ms.\").has_temperature               # temperate\r\nUser.name_like(\"Ms.\").first.last_five_messages.has_temperature # warm\r\n```\r\n\r\nReference Date\r\n-----\r\n\r\nThe temperature is measured by the age of a record or the average age of a set of records from a reference date.\r\nBy default, this reference date is DateTime.now.  However you can change the reference date when making calls to\r\nthe three main methods of this Gem. For example , on `has_temperature` :\r\n\r\n```ruby\r\nUser.first.has_temperature\r\n => \"frosty\"\r\nUser.first.has_temperature date_reference: DateTime.now # equivalent to above call\r\n => \"frosty\"\r\nUser.first.has_temperature date_reference: DateTime.now - 2.month # what was the temperature 2 months ago.\r\n => \"temperate\"\r\n\r\nUser.last.oldest_messages.has_temperature\r\n => \"frosty\"\r\n User.last.oldest_messages.has_temperature date_reference: DateTime.now - 2.months\r\n => \"chilly\"\r\n```\r\n\r\n### Why is this useful?\r\n\r\nIterating through a range of dates to find temperatures can provide data for a heat map. This code example iterates over\r\n the last month for a User.\r\n\r\n```ruby\r\nheat_map = Hash.new\r\nfirst = DateTime.now - 1.month\r\nlast  = DateTime.now\r\nfirst.upto(last).each do |d| heat_map[d.strftime('%F')] = ( User.first.has_temperature date_reference: d ) end\r\nheat_map\r\n=> {\"2014-01-25\"=>\"cold\", \"2014-01-26\"=>\"cold\", \"2014-01-27\"=>\"cold\", \"2014-01-28\"=>\"cold\", \"2014-01-29\"=>\"cold\",\r\n    \"2014-01-30\"=>\"cold\", \"2014-01-31\"=>\"cold\", \"2014-02-01\"=>\"cold\", \"2014-02-02\"=>\"cold\", \"2014-02-03\"=>\"cold\",\r\n    \"2014-02-04\"=>\"cold\", \"2014-02-05\"=>\"cold\", \"2014-02-06\"=>\"cold\", \"2014-02-07\"=>\"cold\", \"2014-02-08\"=>\"cold\",\r\n    \"2014-02-09\"=>\"cold\", \"2014-02-10\"=>\"cold\", \"2014-02-11\"=>\"cold\", \"2014-02-12\"=>\"cold\", \"2014-02-13\"=>\"cold\",\r\n    \"2014-02-14\"=>\"frosty\", \"2014-02-15\"=>\"frosty\", \"2014-02-16\"=>\"frosty\", \"2014-02-17\"=>\"frosty\",\r\n    \"2014-02-18\"=>\"frosty\", \"2014-02-19\"=>\"frosty\", \"2014-02-20\"=>\"frosty\", \"2014-02-21\"=>\"frosty\",\r\n    \"2014-02-22\"=>\"frosty\", \"2014-02-23\"=>\"frosty\", \"2014-02-24\"=>\"frosty\", \"2014-02-25\"=>\"frosty\"}\r\n\r\n```\r\n\r\n\r\nOptions\r\n-----\r\n\r\nIn most cases, how you measure the temperature is consistent across Models, and Associations, therefore keep your customizations\r\nglobal by changing options in the YAML file.  However, you could pass through customizations specific to a particular use\r\ncase.\r\n\r\nConfigs can be passed through in a number of scenarios.\r\n\r\n### Overriding options via measures_temperature_for\r\n\r\n```ruby\r\nclass User < ActiveRecord::Base\r\n\r\n  acts_as_thermometer\r\n\r\n  has_many :messages\r\n\r\n  has_many :oldest_messages, -> {where('created_at < ?', 4.months.ago)} , class_name: \"Message\"\r\n  has_many :recent_messages, -> {where('created_at > ? AND created_at < ?', 4.months.ago , 1.month.ago)} , class_name: \"Message\"\r\n  has_many :newest_messages, -> {where('created_at > ?', 1.month.ago)} , class_name: \"Message\"\r\n\r\n  measures_temperature_for :messages, {:explicit=>true, :date => :updated_at}  #only use options defined here\r\n  measures_temperature_for :recent_messages, {:date => 'updated_at'} #use this date, and default options\r\n  measures_temperature_for :newest_messages,\r\n                    {:date => 'messages.updated_at', :sample => 3} #clearly defined date field, sampling 3 records\r\n\r\n end\r\n\r\n```\r\n\r\n```ruby\r\n> User.first.messages.has_temperature\r\n  User Load (0.1ms)  SELECT \"users\".* FROM \"users\" ORDER BY \"users\".\"id\" ASC LIMIT 1\r\n   (1.4ms)  SELECT \"messages\".\"updated_at\" FROM \"messages\" WHERE \"messages\".\"user_id\" = ?  [[\"user_id\", 14035331]]\r\n => \"frosty\"\r\n\r\n> User.first.newest_messages.has_temperature\r\n  User Load (0.2ms)  SELECT \"users\".* FROM \"users\" ORDER BY \"users\".\"id\" ASC LIMIT 1\r\n    (0.6ms)  SELECT messages.created_at FROM \"messages\" WHERE \"messages\".\"user_id\" = ? AND (created_at >\r\n    '2014-01-19 23:44:59.413221') ORDER BY messages.created_at DESC LIMIT 3  [[\"user_id\", 14035331]]\r\n => :none\r\n ```\r\n\r\n### Overriding options via method calls\r\n\r\nYou can pass options on all available methods.\r\n\r\n```ruby\r\n> User.first.newest_messages.has_temperature :sample => 5\r\n  User Load (0.3ms)  SELECT \"users\".* FROM \"users\" ORDER BY \"users\".\"id\" ASC LIMIT 1\r\n   (0.4ms)  SELECT messages.created_at FROM \"messages\" WHERE \"messages\".\"user_id\" = ? AND (created_at > '2014-01-20 00:04:54.558920') ORDER BY messages.created_at DESC LIMIT 5  [[\"user_id\", 14035331]]\r\n => :none\r\n\r\n> User.first.messages.has_temperature :date => 'created_at'\r\n  User Load (0.2ms)  SELECT \"users\".* FROM \"users\" ORDER BY \"users\".\"id\" ASC LIMIT 1\r\n   (0.4ms)  SELECT created_at FROM \"messages\" WHERE \"messages\".\"user_id\" = ?  [[\"user_id\", 14035331]]\r\n => \"freezing\"\r\n\r\n> User.is_colder_than? :warm, :sample => 5\r\n   (0.4ms)  SELECT updated_at FROM \"users\" ORDER BY updated_at DESC LIMIT 5\r\n => false\r\n\r\n> User.first.is_colder_than? :warm, :sample => 5\r\n  User Load (0.2ms)  SELECT \"users\".* FROM \"users\" ORDER BY \"users\".\"id\" ASC LIMIT 1\r\n => true\r\n```\r\n\r\n### Using AREL Relations directly\r\n\r\nYou can chain methods on relations. Note, that without explicitly excluding them, defaults will be applied. This example,\r\nonly samples the last record in the ActiveRecord collection because the default sample size is 1.\r\n\r\n```ruby\r\n> User.where('created_at > ?', (Time.now - 3.weeks)).has_temperature\r\n   (0.5ms)  SELECT updated_at FROM \"users\" WHERE (created_at > '2014-01-30 00:18:13.260406') ORDER BY updated_at DESC LIMIT 1\r\n => \"lukewarm\"\r\n```\r\n\r\nHowever, you can disable this by passing the option `:explicit=>true` and sample the entire set :\r\n\r\n```ruby\r\n> User.where('created_at > ?', (Time.now - 3.weeks)).has_temperature :explicit=>true\r\n   (0.4ms)  SELECT updated_at FROM \"users\" WHERE (created_at > '2014-01-30 00:18:33.207988')\r\n => \"temperate\"\r\n```\r\n\r\nYou can still apply other options :\r\n\r\n```ruby\r\n> User.where('created_at > ?', (Time.now - 3.weeks)).has_temperature :explicit=>true , :date => :updated_at\r\n   (28.7ms)  SELECT \"users\".\"updated_at\" FROM \"users\" WHERE (created_at > '2014-01-30 00:25:23.563479')\r\n => \"temperate\"\r\n\r\n> User.where('created_at > ?', (Time.now - 3.weeks)).has_temperature :explicit=>true , :date => :updated_at, :sample => 6, :order => 'desc'\r\n   (0.4ms)  SELECT \"users\".\"updated_at\" FROM \"users\" WHERE (created_at > '2014-01-30 00:30:26.123044') ORDER BY updated_at DESC LIMIT 6\r\n => \"temperate\"\r\n```\r\n\r\nCopyright\r\n---------\r\n\r\nCopyright (c) 2014 Nick Newell. See LICENSE.txt for further details.\r\n\r\n\r\n\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}